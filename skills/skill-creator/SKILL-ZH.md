---
name: skill-creator
description: Guide for creating effective skills. This skill should be used when users want to create a new skill (or update an existing skill) that extends Claude's capabilities with specialized knowledge, workflows, or tool integrations.
license: Complete terms in LICENSE.txt
---

# 技能创建者

此技能提供创建有效技能的指导。

## 关于技能

技能是模块化、自包含的包，通过提供专门知识、工作流程和工具来扩展Claude的能力。将它们视为特定领域或任务的"入职指南"——它们将Claude从通用代理转变为配备专门知识的专门代理，这些知识是任何模型都无法完全拥有的。

### 技能提供什么

1. 专门工作流程 - 特定领域的多步骤程序
2. 工具集成 - 处理特定文件格式或API的说明
3. 领域专业知识 - 公司特定知识、模式、业务逻辑
4. 捆绑资源 - 脚本、参考和资产，用于复杂和重复的任务

## 核心原则

### 简洁是关键

上下文窗口是公共资源。技能与Claude需要的其他所有东西共享上下文窗口：系统提示、对话历史、其他技能的元数据以及实际用户请求。

**默认假设：Claude已经非常聪明。** 只添加Claude还没有的上下文。挑战每一条信息："Claude真的需要这个解释吗？"和"这段话证明其token成本合理吗？"

喜欢简洁的示例而不是冗长的解释。

### 设置适当的自由度

将特异性级别与任务的脆弱性和可变性相匹配：

**高自由度（基于文本的指令）**：当多种方法有效、决策依赖于上下文或启发式方法指导方法时使用。

**中等自由度（伪代码或带参数的脚本）**：当存在首选模式、一些变化可接受或配置影响行为时使用。

**低自由度（特定脚本，很少参数）**：当操作脆弱且容易出错、一致性至关重要或必须遵循特定顺序时使用。

将Claude想象成在探索一条路径：狭窄的悬崖上的桥梁需要具体的护栏（低自由度），而开放的田野允许多条路线（高自由度）。

### 技能剖析

每个技能由必需的SKILL.md文件和可选的捆绑资源组成：

```
skill-name/
├── SKILL.md (必需)
│   ├── YAML frontmatter元数据 (必需)
│   │   ├── name: (必需)
│   │   ├── description: (必需)
│   │   └── compatibility: (可选，很少需要)
│   └── Markdown指令 (必需)
└── 捆绑资源 (可选)
    ├── scripts/          - 可执行代码 (Python/Bash/etc.)
    ├── references/       - 旨在需要时加载到上下文中以指导Claude过程和思维的文档
    └── assets/           - 不打算加载到上下文中，而是用于Claude产出中的文件
```

#### SKILL.md (必需)

每个SKILL.md由以下组成：

- **Frontmatter (YAML)**：包含`name`和`description`字段（必需），以及可选字段如`license`、`metadata`和`compatibility`。只有`name`和`description`被Claude读取以确定技能何时触发，因此要清楚和全面地说明技能是什么以及何时使用。`compatibility`字段用于记述环境要求（目标产品、系统包等），但大多数技能不需要它。
- **Body (Markdown)**：使用技能的指导和指令。只有在技能触发后（如果有）才加载。

#### 捆绑资源 (可选)

##### 脚本 (`scripts/`)

用于需要确定性可靠性或反复重写的任务的执行代码（Python/Bash/etc.）。

- **何时包含**：当相同代码被反复重写或需要确定性可靠性时
- **示例**：用于PDF旋转任务的`scripts/rotate_pdf.py`
- **好处**：Token效率高、确定性、可能无需加载到上下文窗口中即可执行
- **注意**：脚本可能仍需要被Claude阅读以进行修补或环境特定调整

##### 参考 (`references/`)

旨在需要时加载到上下文中以指导Claude过程和思维的文档和参考材料。

- **何时包含**：关于Claude应该在工作时参考的文档
- **示例**：用于财务模式的`references/finance.md`、用于公司NDA模板的`references/mnda.md`、用于公司政策的`references/policies.md`、用于API规范的`references/api_docs.md`
- **用例**：数据库模式、API文档、领域知识、公司政策、详细工作流程指南
- **好处**：保持SKILL.md精简，只在Claude确定需要时加载
- **最佳实践**：如果文件很大（>10k字），在SKILL.md中包含grep搜索模式
- **避免重复**：信息应该存在于SKILL.md或参考文件中，而不是两者。优先参考文件用于详细信息，除非它对技能真正核心——这保持SKILL.md精简同时使信息可发现而不会占用上下文窗口。只保留真正核心的程序指令和工作流程指导在SKILL.md中；将详细参考材料、模式和示例移动到参考文件。

##### 资产 (`assets/`)

不打算加载到上下中的文件，而是用于Claude产出中。

- **何时包含**：当技能需要将用于最终输出的文件时
- **示例**：用于品牌资产的`assets/logo.png`、用于PowerPoint模板的`assets/slides.pptx`、用于HTML/React模板的`assets/frontend-template/`、用于排版的`assets/font.ttf`
- **用例**：模板、图像、图标、样板代码、字体、将被复制或修改的示例文档
- **好处**：将输出资源与文档分离，使Claude能够使用文件而无需将它们加载到上下文中

#### 技能中不应包含什么

技能应该只包含直接支持其功能的基本文件。不要创建多余的文档或辅助文件，包括：

- README.md
- INSTALLATION_GUIDE.md
- QUICK_REFERENCE.md
- CHANGELOG.md
- 等等

技能应该只包含AI代理完成手头工作所需的关于。它不应该包含关于创建它的过程的辅助上下文、设置和测试程序、面向用户的文档等。创建额外的文档文件只会增加混乱和困惑。

### 渐进式披露设计原则

技能使用三级加载系统来有效管理上下文：

1. **元数据（name + description）** - 始终在上下文中（~100字）
2. **SKILL.md正文** - 当技能触发时（<5k字）
3. **捆绑资源** - 按Claude需要（无限，因为脚本可以在不加载到上下文窗口的情况下执行）

#### 渐进式披露模式

将SKILL.md正文保持精简并在500行以下以最小化上下文膨胀。当接近此限制时将内容拆分到单独的文件中。当将内容拆分到其他文件时，非常重要的是从SKILL.md引用它们并清楚描述何时读取它们，以确保技能的读者知道它们的存在以及何时使用它们。

**关键原则**：当技能支持多种变体、框架或选项时，只保留核心工作流程和选择指导在SKILL.md中。将变体特定细节（模式、示例、配置）移动到单独的参考文件。

**模式1：带参考的高级指南**

```markdown
# PDF处理

## 快速开始

使用pdfplumber提取文本：
[代码示例]

## 高级功能

- **表单填写**：有关完整指南请参见[FORMS.md](FORMS.md)
- **API参考**：有关所有方法请参见[REFERENCE.md](REFERENCE.md)
- **示例**：有关常见模式请参见[EXAMPLES.md](EXAMPLES.md)
```

Claude只在需要时加载FORMS.md、REFERENCE.md或EXAMPLES.md。

**模式2：领域特定组织**

对于具有多个领域的技能，组织内容按领域以避免加载不相关上下文：

```
bigquery-skill/
├── SKILL.md (概述和导航)
└── reference/
    ├── finance.md (收入、计费指标)
    ├── sales.md (机会、管道)
    ├── product.md (API使用、功能)
    └── marketing.md (活动、归因)
```

当用户询问销售指标时，Claude只读取sales.md。

同样，对于支持多种框架或变体的技能，按变体组织：

```
cloud-deploy/
├── SKILL.md (工作流程 + 提供者选择)
└── references/
    ├── aws.md (AWS部署模式)
    ├── gcp.md (GCP部署模式)
    └── azure.md (Azure部署模式)
```

当用户选择AWS时，Claude只读取aws.md。

**模式3：条件详情**

显示基本内容，链接到高级内容：

```markdown
# DOCX处理

## 创建文档

对新房档使用docx-js。参见[DOCX-JS.md](DOCX-JS.md)。

## 编辑文档

对于简单编辑，直接修改XML。

**对于修订追踪**：参见[REDLINING.md](REDLINING.md)
**对于OOXML详情**：参见[OOXML.md](OOXML.md)
```

Claude只在用户需要这些功能时读取REDLINING.md或OOXML.md。

**重要指南**：

- **避免深度嵌套参考** - 将参考保持在SKILL.md的一级深度。所有参考文件应该直接从SKILL.md链接。
- **组织较长的参考文件** - 对于超过100行的文件，在顶部包含目录，以便Claude在预览时可以看到完整范围。

## 技能创建过程

技能创建涉及这些步骤：

1. 用具体示例理解技能
2. 规划可重用的技能内容（脚本、参考、资产）
3. 初始化技能（运行init_skill.py）
4. 编辑技能（实现资源并编写SKILL.md）
5. 打包技能（运行package_skill.py）
6. 基于实际使用迭代

按顺序遵循这些步骤，只有在有明确原因为什么不适用时才跳过。

### 步骤1：用具体示例理解技能

只有当技能的用法模式已经清楚理解时才跳过此步骤。它在处理现有技能时仍然有价值。

要创建有效的技能，清楚理解技能将如何使用具体示例。这个理解可以来自直接用户示例或用用户反馈验证的生成示例。

例如，在构建图像编辑器技能时，相关问题包括：

- "图像编辑器技能应该支持什么功能？编辑、旋转，还有其他吗？"
- "你能给一些这个技能将如何使用的例子吗？"
- "我想象用户询问像'从这个图像中移除红眼'或'旋转这个图像'的事情。你想象这个技能有其他使用方式吗？"
- "用户说什么会触发这个技能？"

为了避免让用户不知所措，避免在一条消息中问太多问题。从最重要的问题开始，根据需要跟进以获得更好效果。

当对技能应该支持的功能有清晰感觉时结束此步骤。

### 步骤2：规划可重用的技能内容

要将具体示例转化为有效技能，通过以下方式分析每个示例：

1. 考虑如何从零开始执行示例
2. 识别在反复执行这些工作流程时会有帮助的脚本、参考和资产

示例：在构建处理如"帮助我旋转这个PDF"查询的`pdf-editor`技能时，分析显示：

1. 旋转PDF需要每次重写相同代码
2. `scripts/rotate_pdf.py`脚本会很有帮助以存储在技能中

示例：在设计处理如"为我构建待办应用"或"为我构建仪表板来跟踪我的步数"查询的`frontend-webapp-builder`技能时，分析显示：

1. 编写前端Webapp每次需要相同的样板HTML/React
2. `assets/hello-world/`模板包含样板HTML/React项目文件会很有帮助以存储在技能中

示例：在构建处理如"今天有多少用户登录了？"查询的`big-query`技能时，分析显示：

1. 查询BigQuery每次需要重新发现表模式和关系
2. `references/schema.md`文件记录表模式会很有帮助以存储在技能中

要建立技能的内容，分析每个具体示例以创建要包含的可重用什么资源的列表：脚本、参考和资产。

### 步骤3：初始化技能

现在是时候实际创建技能了。

只有当正在开发的技能已经存在、需要迭代或打包时才跳过此步骤。在这种情况下，继续下一步。

当从零创建新技能时，始终运行`init_skill.py`脚本。该脚本方便地生成新的模板技能目录，自动包含技能需要的所有东西，使技能创建过程更高效和可靠。

用法：
```bash
scripts/init_skill.py <skill-name> --path <output-directory>
```

该脚本：
- 在指定路径创建技能目录
- 生成带适当frontmatter和TODO占位符的SKILL.md模板
- 创建示例资源目录：`scripts/`、`references/`和`assets/`
- 在每个目录中添加可以自定义或删除的示例文件

初始化后，根据需要自定义或删除生成的SKILL.md和示例文件。

### 步骤4：编辑技能

编辑（新生成的或现有的）技能时，请记住正在为另一个Claude实例创建技能。包括对另一个Claude实例有益且不明显的信息。考虑什么程序知识、领域特定细节或可重用资产会帮助另一个Claude实例更有效地执行这些任务。

#### 学习经过验证的设计模式

根据技能的需要咨询这些有用的指南：

- **多步骤过程**：参见references/workflows.md以获取顺序工作流程和条件逻辑
- **特定输出格式或质量标准**：参见references/output-patterns.md以获取模板和示例模式

这些文件包含有效技能设计的既定最佳实践。

#### 从可重用的技能内容开始

要开始实现，从上面识别的可重用资源开始：`scripts/`、`references/`和`assets/`文件。注意此步骤可能需要用户输入。例如，在实现`brand-guidelines`技能时，用户可能需要提供品牌资产或模板以存储在`assets/`中，或文档以存储在`references/`中。

添加的脚本必须通过实际运行它们来测试，以确保没有错误并且输出符合预期。如果有许多相似的脚本，只测试代表性样本以确保对它们都有信心，同时平衡完成时间。

任何不需要技能的示例文件和目录应该被删除。初始化脚本在`scripts/`、`references/`和`assets/`中创建示例文件以演示结构，但大多数技能不需要所有这些。

#### 更新SKILL.md

**写作指南**：始终使用祈使句/不定式形式。

##### Frontmatter

用`name`和`description`编写YAML frontmatter：

- `name`：技能名称
- `description`：这是技能的主要触发机制，帮助Claude理解何时使用技能。
  - 包括技能做什么以及使用它的具体触发器/上下文。
  - 将所有"何时使用"信息包括在这里——不在正文中。正文只有在触发后加载，所以正文中的"何时使用此技能"部分对Claude没有帮助。
  - 例如`docx`技能的描述："全面的文档创建、编辑和分析，支持修订追踪、注释、格式保留和文本提取。当Claude需要使用专业文档（.docx文件）进行：（1）创建新文档，（2）修改或编辑内容，（3）处理修订追踪，（4）添加注释，或任何其他文档任务时使用"

不要在YAML frontmatter中包含任何其他字段。

##### Body

编写使用技能及其捆绑资源的指令。

### 步骤5：打包技能

一旦技能开发完成，必须将其打包成可分发的.skill文件，与用户共享。打包过程首先自动验证技能以确保它满足所有要求：

```bash
scripts/package_skill.py <path/to/skill-folder>
```

可选输出目录规范：
```bash
scripts/package_skill.py <path/to/skill-folder> ./dist
```

打包脚本将：

1. **自动验证**技能，检查：
   - YAML frontmatter格式和必需字段
   - 技能命名约定和目录结构
   - 描述完整性和质量
   - 文件组织和资源引用

2. 如果验证通过，**打包**技能，创建名为技能名称的.skill文件（例如`my-skill.skill`），包括所有文件并保持适当的目录结构以进行分发。.skill文件是带有.skill扩展名的zip文件。

如果验证失败，脚本将报告错误并退出而不创建包。修复任何验证错误并再次运行打包命令。

### 步骤6：迭代

测试技能后，用户可能要求改进。这通常发生在使用技能后，对技能表现有新鲜上下文时立即发生。

**迭代工作流程**：

1. 对真实任务使用技能
2. 注意到挣扎或低效
3. 识别SKILL.md或捆绑资源应该如何更新
4. 实现更改并再次测试
